# BTCR v0.1 Decisions

Authors: Kim Hamilton Duffy

Contributors: Dan Pape, Ryan Grant, Christopher Allen, Anthony Ronning, Ganesh Annan, Wolf McNally

## Abstract
The Bitcoin Reference (BTCR) DID method supports DIDs using the Bitcoin blockchain. This method has been under development through Rebooting Web of Trust events and hackathons over the past year. The BTCR method's reliance on the Bitcoin blockchain presents both advantages and design challenges. During RWOT7, the authors made a number of design decisions -- largely scope-cutting in nature -- in order to lock down an MVP version, which we'll refer to as v0.1. This paper documents those decisions, which will apply to the upcoming v0.1 BTCR method specification and associated v0.1 BTCR reference implementation.

## Overview

The design decisions include:
- What's in and out of scope
- BTCR semantics
- Wallet functionality
- Credential schema and content

## Scope clarifications

The most critical aspects to locking down a v0.1 of the BTCR method is defining what's out of scope. These are aspects where that either introduced a large amount of complexity or presented implementation difficulties given currently available libraries. These will assuredly be addressed in later versions of the BTCR method. 

### 1. Assume P2PKH scripts
Our initial BTCR implementations relied on Pay to Public Key Hash (P2PKH) scripts. We explored other script types, but these introduced complications extracting the signing public key directly from the transaction, which we require for the final DID document.

For this reason, we decided that only P2PKH scripts are supported, and other scripts types -- for example P2SH and Segwit -- are out of scope.

Because of the size and cost implications, we will revisit this decision in later versions.

### 2. Only a HTTP URL in OP_RETURN (Note: no IPFS support)

#### Context

A BTCR transaction allows an optional OP_RETURN field pointing to a "continuation" DID document, which is a DID document containing additional key material and capabilities to be merged into the final BTCR DID Document (generated by the resolver).

The storage type of the continuation document introduced a fork: if the link in the transaction pointed to mutable storage, the document could be updated after the transaction with the known DID (which isn't known until after the tx has been confirmed). However, if the link was a cryptographic hash link, then document could not be changed without invalidating the hash.

For the latter case, we addressed this by considering the transaction signature an implicit signature on the immutable content. This introduces a requirement for the resolvers to be aware of different link types (which are content hashes or not), which we've tracked [here](https://github.com/w3c-ccg/didm-btcr/issues/2).

#### v0.1 Scope Reduction: no special path for immutable continuation DID documents

To reduce scope, we will assume in v0.1 that, if the OP_RETURN is present, it points to a HTTP URL. We also assume that the target content could have been altered. 

This allows us to cut scope and address the case of mutable storage only.

> TODO: I still don't fully understand this call. The reasons we state are mobile dependencies, but it's not obvious to me that the mobile wallet would also have to host the IPFS object. 

From Christopher:

We can't support IPFS because there are no guarantees of pinning of IPFS objects. The IPFS lib on iPhone has to be running all the time, and canâ€™t be running the in background. We need to either wait for greater support on phone for ipfs, or use something like filecoin

### 3. Continuation DID Document in github

Extending on the previous decision, we've decided in v0.1 to store continuation DID Documents in github. The continuation DID Document must be updated after tx confirmation as follows:
1. the DID populating relevant fields, e.g. `id`. The DID will be known after the BTCR tx is confirmed.
2. a signature on the updated DID Document from the tx signing key

> TODO: add more details about github somewhere
- advantage: can tie to pgp 
- disadvantage: need github account (ok, dev audience)

### 4. Testnet only

Most importantly, we've decided to only support testnet (not mainnet) as we work through the initial reference implementations and obtain feedback from test usage.

## Semantics

A BTCR DID document relies partially on transaction structure, partially on the continuation DID document. We clarified the semantics of scenarios that were previously undefined. 

### 1. Transaction input/output semantics

#### a. TX Input addresses

In v0.1, the keypair corresponding to the 1st TX input has the following properties:
- it is the only key that can be used to verify control of DID and continuation DID document
- it must be used to sign the updated continuation DID document (after TX confirmation)

If an OP_RETURN doesn't exist, the keypair corresponding to the 1st TX input is granted the following additional capabilities (by the resolver):
- DID auth
- sign/verify Verifiable Credentials

If the OP_RETURN exists, the continuation DID document obviates the need for additional implicit capabilities; we assume each capability is listed explicitly in the continuation DID document.

#### b. TX Output address (1st monetary output)

Used for "following the tip". If spent, the BTCR DID has either been rotated or revoked. Resolvers must follow the tip to find the latest transaction. 

Whether the DID has been rotated or revoked is determined by the next section.

### 2. No OP_RETURN after a TX means revoked

A BTCR DID is considered revoked if:
- There is more than 1 transaction in the BTCR DID "chain"
- The latest transaction has no OP_RETURN

The first factor is important because a missing OP_RETURN is considered valid in the very first tx in the chain. However, all subsequent txs in the chain must have OP_RETURNs or else it is considered revoked.

This behavior is enforced by BTCR resolvers.

## Wallet functionality

### 1. Import previous Bitcoin transactions

The v0.1 BTCR wallet implementation will support importing existing private keys corresponding to unspent outputs from previous transactions. This allows users to generate a valid BTCR DID from an existing transaction, with no additional cost.

A consequence is that a transaction doesn't need to be created or broadcast (from within the ID wallet) to instantiate this initial BTCR DID. The ID wallet only needs to create transactions for any subsequent update/revoke operations.

In this case, the BTCR DID will have no continuation DID Document.

### 2. Updates must use non-financial HD derivation paths

We want to allow users to share mnemonic seeds across their ID wallet and their Bitcoin wallets. To achieve this, we must make sure addresses backing valid DIDs are not accidentally spent, which would result in a BTCR DID revocation.

We will achieve this by choosing our own convention about the derivation path.

### 3. Tip following

> TODO: this section needs work

- Ideally follow best practice BIP 157/158. Problem is that libraries not necessarily available. 
- Fallback is Kulpreet's REST service.

About BIP 157/158
- Neutrino
- Lightning branch of Go code
- Not as efficient as SPV: SPV requests lists of addresses it cares about. Neutro slower because it attempts to hide addresses it cares about.


## Credential schema and content

> TODO: this section needs work

### 1. Use JSON-LD 1.1 javascript lib, because 0.1 doesn't need hardcore verifiers
### 2. Restrict to schema.org schemas. Can use Christopher's test cases
### 3. Privacy: stick to pseudoanonymous claim content
### 4. Restrict to VCs one wishes to share


> TODO also add somewhere: Can prerevoke in case of emergency 


> TODO: update this sample

```
{
  "didDocument": {
    "@context": "https://w3id.org/did/v1",
    "publicKey": [
      {
        "id": "#keys-2",
        "type": "RsaVerificationKey2018",
        "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
      }
    ],
    "authentication": [
      {
        "type": "RsaSignatureAuthentication2018",
        "publicKey": "#keys-2"
      }
    ]
  },
  "claims": [
  
  ]
}
```
